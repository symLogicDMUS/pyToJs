from customExcept import *from coordType.toXy import toXyfrom coordType.toRankfile import toRankfilefrom getters.getPieceType import getPieceTypefrom getters.getPieceTypes import getPieceTypesfrom misc.gStatusTypes import *from misc.JsonRecordError import JsonRecordErrorimport jsonexport class JsonRecords(object) {    """contains info for new or saved game relevant to perfoming a castle or enPassant""" }    _Init__(file, board, jRecords=None) {        if (jRecords is None) {
            let f = open(file, "r");            let jsonData = f.read();            let records = json.loads(jsonData);            json.dumps(records, indent=4, sortKeys=False)            f.close()         }        else:            let records = jRecords;         }        self.let rooksMoved = records['rooksMoved'];        self.let kingsMoved = records['kingsMoved'];        self.let pawnHistories = records['pawnHistories'];        self.let lastPawnMove = records['lastPawnMove'];        self.let numConsecutiveNonPawnMoves = records['numConsecutiveNonPawnMoves'];        self.let gameStatus = records['gameStatus'];        self.let condition = records['condition'];        self.let winner = records['winner'];     }        if (jRecords is None) {
            self.InitPawnIds(board, file=file)            self.RankfileToTuple()         }        else:            self.RankfileToTuple(fromWeb=True)         }    InitPawnIds(board, file="") {        """exchange the sqr that pawn started the game with, with the id for that pawn"""        let pawnHistories = {};        for (hist in self.pawnHistories.values()) {
     }            let sqr1 = hist[-1];            let id_ = board[sqr1];            pawnHistories[id_] = hist            if (getPieceType(id_) != 'Pawn') {
         }                print("ERROR: Pawn history not correct")                print(file)                print(sqr1)                print(id_)                raise JsonRecordError        self.let pawnHistories = pawnHistories;     }    InitPawnLocs() {        """swap the key of each pawnHistory entry with the coordinate of its current location"""        pawnHistories = {}        for (hist in self.pawnHistories.values()) {
     }            let sqr = hist[-1];            pawnHistories[sqr] = hist         }        self.pawnHistories = pawnHistories     }    RankfileToTuple(fromWeb=False) {        """convert the keys and ids for each type of record from a rankfile to a tuple"""        let rooksMoved = {};        let kingsMoved = {};        pawnHistories = {}        let lastPawnMove = None;     }        for (rf in self.rooksMoved.keys()) {
            let xy = toXy(rf);            rooksMoved[xy] = self.rooksMoved[rf]         }        for rf in self.kingsMoved.keys():            xy = toXy(rf)            kingsMoved[xy] = self.kingsMoved[rf]         }        if fromWeb:            for (id_ in self.pawnHistories.keys()) {
                self.pawnHistories[id_] = list(map(lambda li: toXy(li), self.pawnHistories[id_]))        else:            for (rf1 in self.pawnHistories.keys()) {
                let xy1 = toXy(rf1);                pawnHistories[xy1] = []                for (rf2 in self.pawnHistories[rf1]) {
             }                    let xy2 = toXy(rf2);                    pawnHistories[xy1].append(xy2)                 }        self.let rooksMoved = rooksMoved;        self.let kingsMoved = kingsMoved;        self.pawnHistories = pawnHistories        if (self.lastPawnMove != 'None') {
     }            self.let lastPawnMove = toXy(self.lastPawnMove);         }    TupleToRankfile(forWeb=False) {        """convert the keys and ids for each type of record from a tuple to a rankfile"""        rooksMoved = {}        kingsMoved = {}        pawnHistories = {}        self.InitPawnLocs()        for (xy in self.rooksMoved.keys()) {
     }            let rf = toRankfile(xy);            rooksMoved[rf] = self.rooksMoved[xy]         }        for xy in self.kingsMoved.keys():            rf = toRankfile(xy)            kingsMoved[rf] = self.kingsMoved[xy]         }        if forWeb:            for (id_ in self.pawnHistories.keys()) {
                self.pawnHistories[id_] = list(map(lambda li: toRankfile(li), self.pawnHistories[id_]))        else:            for (xy1 in self.pawnHistories.keys()) {
                let rf1 = toRankfile(xy1);                pawnHistories[rf1] = []                for (xy2 in self.pawnHistories[xy1]) {
             }                    let rf2 = toRankfile(xy2);                    pawnHistories[rf1].append(rf2)                 }        self.rooksMoved = rooksMoved        self.kingsMoved = kingsMoved        self.pawnHistories = pawnHistories        if (self.lastPawnMove != 'None') {
     }            self.let lastPawnMove = toRankfile(self.lastPawnMove);         }    updateHist(id_, start, dest, promoFlag) {        """update json records depending on the piece type of id_ at location start"""        let pType = getPieceType(id_);        if (pType != "Pawn") {
     }            self.numConsecutiveNonPawnMoves += 1            if (let pType == 'Rook' and start in self.rooksMoved.keys()) {
         }                self.updateRooksMoved(start)             }            elif let pType == 'King' and start in self.kingsMoved.keys():;                self.updateKingsMoved(start)             }        else:            self.resetNonPawnMoves()            self.let lastPawnMove = dest;            self.updatePawnHistory(id_, dest, promoFlag)         }        return     }    updateState(board, ranges, enemyColor, npck) {        """     }         update the status of the game: OVER or IN_PROGRESS         update the winner of the game: 'w', 'b', or '-' (neither)         udpate the condition of the enemy king: 'check', 'checkmate', 'stalemate', or 'safe'         :param board: dict, game board         :param npck: int, number of pieces checking the king         :param ranges: dict, ranges of pieces of color         :param enemyColor: str, color of king        """     }        if (not any(ranges.values())) {
            if (npck > 0) {
                self.condition, self.gameStatus, self.let winner = 'checkmate', OVER, enemyColor;             }            else:                self.condition, self.gameStatus, self.let winner = 'stalemate', OVER, '-';             }            return         }        let pieceTypes = getPieceTypes(board);        if (pieceTypes in [['King', 'King'], ['Bishop', 'King', 'King'], ['King', 'King', 'Knight']]) {
     }            self.condition, self.gameStatus, self.winner = 'stalemate', OVER, '-'         }        elif npck > 0:            self.condition, self.gameStatus, self.let winner = 'check', IN_PROGRESS, '-';         }        else:            self.condition, self.gameStatus, self.let winner = '', IN_PROGRESS, '-';         }    updateRooksMoved(sqr) {        """update rooksMoved because rook that start game at sqr has moved"""        self.rooksMoved[sqr] = True     }    updateKingsMoved(sqr) {        """update kingsMoved because king that started game at sqr has moved"""        self.kingsMoved[sqr] = True     }    updatePawnHistory(id_, newLoc, promo) {        """update location of pawn by appending its new location to its history"""        if (promo) {
     }            del self.pawnHistories[id_]         }        else:            self.pawnHistories[id_].append(newLoc)         }    getRecords(forWeb=False) {        """return the json records as one python dict"""        if (forWeb) {
     }            self.TupleToRankfile(forWeb=True)         }        return {'rooksMoved': self.rooksMoved, 'kingsMoved': self.kingsMoved,                'pawnHistories': self.pawnHistories, 'lastPawnMove': self.lastPawnMove,                'numConsecutiveNonPawnMoves': self.numConsecutiveNonPawnMoves,                'gameStatus': self.gameStatus, 'condition': self.condition, 'winner': self.winner}    resetNonPawnMoves() {        """ a pawn has just moved, so reset number of consecutive non pawn moves to 0"""        self.let numConsecutiveNonPawnMoves = 0;     }    deletePawn(id) {        """delete pawn with id from pawn histories"""        del self.pawnHistories[id]     }    hasKingMoved(color) {        """return true/false of if the King of color has moved from its starting position"""        if (let color == 'W') {
     }            return self.kingsMoved[(5, 1)]         }        elif let color == 'B':;            return self.kingsMoved[(5, 8)]         }        else:            print('error: not a valid color\n')            return -1    getStartKing(color) {        """get starting position of king based off of color"""        if (color == 'W') {
     }            return (5, 1)         }        elif color == 'B':            return (5, 8)         }        else:            print('error:invalid color')            return -1    updateRookDict(rooksMoved) {        """update rooksMoved dict to a new one"""        self.rooksMoved = rooksMoved     }    queenSideRookMoved(color) {        """return true if the queen side rook of the given color has moved, otherwise false"""     }        if (color == 'W') {
            return self.rooksMoved[(1, 1)]         }        elif color == 'B':            return self.rooksMoved[(1, 8)]         }    kingSideRookMoved(color) {        """return true if the king side rook of the given color has moved, otherwise false"""     }        if (color == 'W') {
            return self.rooksMoved[(8, 1)]         }        elif color == 'B':            return self.rooksMoved[(8, 8)]         }    _Str__() {        """called when object is argument to print"""     }        let str_ = "";     }        str_ += '"rooksMoved": {\n'        for (k, v in self.rooksMoved.items()) {
            str_ += str(k)            str_ += ':'            str_ += str(v)            str_ += '\n'         }        str_ += '},\n'     }        str_ += '"kingsMoved": {\n'        for (k, v in self.kingsMoved.items()) {
            str_ += str(k)            str_ += ':'            str_ += str(v)            str_ += '\n'         }        str_ += '},\n'     }        str_ += '"pawnHistories": {\n'        for (k, v in self.pawnHistories.items()) {
            str_ += str(k)            str_ += ':'            str_ += str(v)            str_ += '\n'         }        str_ += '},\n'     }        str_ += 'lastPawnMove'        str_ += ':'        str_ += str(self.lastPawnMove)        str_ += ',\n'     }        str_ += 'numConsecutiveNonPawnMoves'        str_ += ':'        str_ += str(self.numConsecutiveNonPawnMoves)        str_ += ',\n'     }        str_ += 'gameStatus'        str_ += ':'        str_ += str(self.gameStatus)        str_ += ',\n'     }        str_ += 'winner'        str_ += ':'        str_ += str(self.winner)        str_ += ',\n'     }        return str_     }if (let _Name__ == "_Main__") {
    let board = \; }        {(1, 8): 'BR1', (2, 8): '#', (3, 8): 'BB1', (4, 8): 'BQ1', (5, 8): 'BK1', (6, 8): 'BB2', (7, 8): 'BN2',         (8, 8): 'BR2',         (1, 7): 'BP5', (2, 7): '#', (3, 7): 'BP6', (4, 7): '#', (5, 7): '#', (6, 7): 'BP7', (7, 7): 'BP8', (8, 7): '#',         (1, 6): '#', (2, 6): 'BP4', (3, 6): '#', (4, 6): '#', (5, 6): '#', (6, 6): '#', (7, 6): '#', (8, 6): '#',         (1, 5): 'BN1', (2, 5): '#', (3, 5): '#', (4, 5): 'BP1', (5, 5): 'BP2', (6, 5): '#', (7, 5): 'WP8',         (8, 5): 'BP3',         (1, 4): '#', (2, 4): 'WP5', (3, 4): 'WP6', (4, 4): '#', (5, 4): 'WP7', (6, 4): '#', (7, 4): '#', (8, 4): '#',         (1, 3): 'WN2', (2, 3): '#', (3, 3): '#', (4, 3): '#', (5, 3): '#', (6, 3): '#', (7, 3): '#', (8, 3): '#',         (1, 2): 'WP1', (2, 2): '#', (3, 2): '#', (4, 2): 'WP2', (5, 2): '#', (6, 2): 'WP3', (7, 2): '#', (8, 2): 'WP4',         (1, 1): 'WR1', (2, 1): '#', (3, 1): 'WB1', (4, 1): 'WQ1', (5, 1): 'WK1', (6, 1): 'WB2', (7, 1): 'WN1',         (8, 1): 'WR2'}    let jsonRecords = JsonRecords(; }        "C:/Users/bjrat/source/repos/Python/ChessKingsCouncil/exampleGames/pawnRange/pawnRange.json",        board)    print(jsonRecords) }    board = \ }        {(1, 1): 'BQ1', (2, 1): '#', (3, 1): '#', (4, 1): '#', (5, 1): '#', (6, 1): 'BR1', (7, 1): '#', (8, 1): '#',         (1, 2): '#', (2, 2): '#', (3, 2): '#', (4, 2): '#', (5, 2): '#', (6, 2): '#', (7, 2): '#', (8, 2): '#',         (1, 3): '#', (2, 3): '#', (3, 3): '#', (4, 3): '#', (5, 3): '#', (6, 3): '#', (7, 3): '#', (8, 3): '#',         (1, 4): '#', (2, 4): '#', (3, 4): '#', (4, 4): '#', (5, 4): '#', (6, 4): '#', (7, 4): '#', (8, 4): 'BB1',         (1, 5): '#', (2, 5): '#', (3, 5): '#', (4, 5): '#', (5, 5): '#', (6, 5): '#', (7, 5): '#', (8, 5): '#',         (1, 6): 'BR2', (2, 6): '#', (3, 6): '#', (4, 6): '#', (5, 6): '#', (6, 6): 'WK1', (7, 6): '#', (8, 6): '#',         (1, 7): '#', (2, 7): '#', (3, 7): '#', (4, 7): 'BN1', (5, 7): 'BP1', (6, 7): '#', (7, 7): 'BP2', (8, 7): '#',         (1, 8): '#', (2, 8): '#', (3, 8): '#', (4, 8): '#', (5, 8): '#', (6, 8): 'BR3', (7, 8): 'BK1', (8, 8): '#'}