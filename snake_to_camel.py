import re


def snake_to_camel(lines):
    """ """
    for i in range(len(lines)):
        if re.search(r'_[a-z]', lines[i]) is not None:
            matches = re.findall(r'_[a-z]', lines[i])
            for s_str in matches:
                if lines[i].startswith(s_str):
                    lines[i] = lines[i].replace(s_str, s_str[1])
                else:
                    lines[i] = lines[i].replace(s_str, s_str[1].upper())
    return lines


if __name__ == "__main__":
    lines = \
        ['from custom_except import *\n',
         'from coordType.to_xy import to_xy\n',
         'from coordType.to_rankfile import to_rankfile\n',
         'from getters.get_piece_type import get_piece_type\n',
         'from getters.get_piece_types import get_piece_types\n',
         'from misc.g_status_types import *\n',
         'from misc.JsonRecordError import JsonRecordError\n',
         'import json\n',
         '\n',
         '\n',
         'class JsonRecords(object):\n',
         '    """contains info for new or saved game relevant to perfoming a castle or '
         'en_passant"""\n',
         '\n',
         '    def __init__(self, file, board, j_records=None):\n',
         '\n',
         '        if j_records is None:\n',
         '            f = open(file, "r")\n',
         '            json_data = f.read()\n',
         '            records = json.loads(json_data)\n',
         '            json.dumps(records, indent=4, sort_keys=False)\n',
         '            f.close()\n',
         '        else:\n',
         '            records = j_records\n',
         '\n',
         "        self.rooks_moved = records['rooks_moved']\n",
         "        self.kings_moved = records['kings_moved']\n",
         "        self.pawn_histories = records['pawn_histories']\n",
         "        self.last_pawn_move = records['last_pawn_move']\n",
         '        self.num_consecutive_non_pawn_moves = '
         "records['num_consecutive_non_pawn_moves']\n",
         "        self.game_status = records['game_status']\n",
         "        self.condition = records['condition']\n",
         "        self.winner = records['winner']\n",
         '\n',
         '        if j_records is None:\n',
         '            self._init_pawn_ids(board, file=file)\n',
         '            self._rankfile_to_tuple()\n',
         '        else:\n',
         '            self._rankfile_to_tuple(from_web=True)\n',
         '\n',
         '    def _init_pawn_ids(self, board, file=""):\n',
         '        """exchange the sqr that pawn started the game with, with the id for '
         'that pawn"""\n',
         '        pawn_histories = {}\n',
         '        for hist in self.pawn_histories.values():\n',
         '            sqr1 = hist[-1]\n',
         '            id_ = board[sqr1]\n',
         '            pawn_histories[id_] = hist\n',
         "            if get_piece_type(id_) != 'Pawn':\n",
         '                print("ERROR: Pawn history not correct")\n',
         '                print(file)\n',
         '                print(sqr1)\n',
         '                print(id_)\n',
         '                raise JsonRecordError\n',
         '        self.pawn_histories = pawn_histories\n',
         '\n',
         '    def _init_pawn_locs(self):\n',
         '        """swap the key of each pawn_history entry with the coordinate of '
         'its current location"""\n',
         '        pawn_histories = {}\n',
         '        for hist in self.pawn_histories.values():\n',
         '            sqr = hist[-1]\n',
         '            pawn_histories[sqr] = hist\n',
         '        self.pawn_histories = pawn_histories\n',
         '\n',
         '    def _rankfile_to_tuple(self, from_web=False):\n',
         '        """convert the keys and ids for each type of record from a rankfile '
         'to a tuple"""\n',
         '        rooks_moved = {}\n',
         '        kings_moved = {}\n',
         '        pawn_histories = {}\n',
         '        last_pawn_move = None\n',
         '\n',
         '        for rf in self.rooks_moved.keys():\n',
         '            xy = to_xy(rf)\n',
         '            rooks_moved[xy] = self.rooks_moved[rf]\n',
         '        for rf in self.kings_moved.keys():\n',
         '            xy = to_xy(rf)\n',
         '            kings_moved[xy] = self.kings_moved[rf]\n',
         '        if from_web:\n',
         '            for id_ in self.pawn_histories.keys():\n',
         '                self.pawn_histories[id_] = list(map(lambda li: to_xy(li), '
         'self.pawn_histories[id_]))\n',
         '        else:\n',
         '            for rf1 in self.pawn_histories.keys():\n',
         '                xy1 = to_xy(rf1)\n',
         '                pawn_histories[xy1] = []\n',
         '                for rf2 in self.pawn_histories[rf1]:\n',
         '                    xy2 = to_xy(rf2)\n',
         '                    pawn_histories[xy1].append(xy2)\n',
         '        self.rooks_moved = rooks_moved\n',
         '        self.kings_moved = kings_moved\n',
         '        self.pawn_histories = pawn_histories\n',
         "        if self.last_pawn_move != 'None':\n",
         '            self.last_pawn_move = to_xy(self.last_pawn_move)\n',
         '\n',
         '    def _tuple_to_rankfile(self, for_web=False):\n',
         '        """convert the keys and ids for each type of record from a tuple to '
         'a rankfile"""\n',
         '        rooks_moved = {}\n',
         '        kings_moved = {}\n',
         '        pawn_histories = {}\n',
         '        self._init_pawn_locs()\n',
         '        for xy in self.rooks_moved.keys():\n',
         '            rf = to_rankfile(xy)\n',
         '            rooks_moved[rf] = self.rooks_moved[xy]\n',
         '        for xy in self.kings_moved.keys():\n',
         '            rf = to_rankfile(xy)\n',
         '            kings_moved[rf] = self.kings_moved[xy]\n',
         '        if for_web:\n',
         '            for id_ in self.pawn_histories.keys():\n',
         '                self.pawn_histories[id_] = list(map(lambda li: '
         'to_rankfile(li), self.pawn_histories[id_]))\n',
         '        else:\n',
         '            for xy1 in self.pawn_histories.keys():\n',
         '                rf1 = to_rankfile(xy1)\n',
         '                pawn_histories[rf1] = []\n',
         '                for xy2 in self.pawn_histories[xy1]:\n',
         '                    rf2 = to_rankfile(xy2)\n',
         '                    pawn_histories[rf1].append(rf2)\n',
         '        self.rooks_moved = rooks_moved\n',
         '        self.kings_moved = kings_moved\n',
         '        self.pawn_histories = pawn_histories\n',
         "        if self.last_pawn_move != 'None':\n",
         '            self.last_pawn_move = to_rankfile(self.last_pawn_move)\n',
         '\n',
         '    def update_hist(self, id_, start, dest, promo_flag):\n',
         '        """update json records depending on the piece type of id_ at '
         'location start"""\n',
         '        p_type = get_piece_type(id_)\n',
         '        if p_type != "Pawn":\n',
         '            self.num_consecutive_non_pawn_moves += 1\n',
         "            if p_type == 'Rook' and start in self.rooks_moved.keys():\n",
         '                self.update_rooks_moved(start)\n',
         "            elif p_type == 'King' and start in self.kings_moved.keys():\n",
         '                self.update_kings_moved(start)\n',
         '        else:\n',
         '            self.reset_non_pawn_moves()\n',
         '            self.last_pawn_move = dest\n',
         '            self.update_pawn_history(id_, dest, promo_flag)\n',
         '        return\n',
         '\n',
         '    def update_state(self, board, ranges, enemy_color, npck):\n',
         '        """\n',
         '         update the status of the game: OVER or IN_PROGRESS\n',
         "         update the winner of the game: 'w', 'b', or '-' (neither)\n",
         "         udpate the condition of the enemy king: 'check', 'checkmate', "
         "'stalemate', or 'safe'\n",
         '         :param board: dict, game board\n',
         '         :param npck: int, number of pieces checking the king\n',
         '         :param ranges: dict, ranges of pieces of color\n',
         '         :param enemy_color: str, color of king\n',
         '        """\n',
         '\n',
         '        if not any(ranges.values()):\n',
         '            if npck > 0:\n',
         "                self.condition, self.game_status, self.winner = 'checkmate', "
         'OVER, enemy_color\n',
         '            else:\n',
         "                self.condition, self.game_status, self.winner = 'stalemate', "
         "OVER, '-'\n",
         '            return\n',
         '\n',
         '        piece_types = get_piece_types(board)\n',
         "        if piece_types in [['King', 'King'], ['Bishop', 'King', 'King'], "
         "['King', 'King', 'Knight']]:\n",
         "            self.condition, self.game_status, self.winner = 'stalemate', "
         "OVER, '-'\n",
         '        elif npck > 0:\n',
         "            self.condition, self.game_status, self.winner = 'check', "
         "IN_PROGRESS, '-'\n",
         '        else:\n',
         "            self.condition, self.game_status, self.winner = '', IN_PROGRESS, "
         "'-'\n",
         '\n',
         '    def update_rooks_moved(self, sqr):\n',
         '        """update rooks_moved because rook that start game at sqr has '
         'moved"""\n',
         '        self.rooks_moved[sqr] = True\n',
         '\n',
         '    def update_kings_moved(self, sqr):\n',
         '        """update kings_moved because king that started game at sqr has '
         'moved"""\n',
         '        self.kings_moved[sqr] = True\n',
         '\n',
         '    def update_pawn_history(self, id_, new_loc, promo):\n',
         '        """update location of pawn by appending its new location to its '
         'history"""\n',
         '        if promo:\n',
         '            del self.pawn_histories[id_]\n',
         '        else:\n',
         '            self.pawn_histories[id_].append(new_loc)\n',
         '\n',
         '    def get_records(self, for_web=False):\n',
         '        """return the json records as one python dict"""\n',
         '        if for_web:\n',
         '            self._tuple_to_rankfile(for_web=True)\n',
         "        return {'rooks_moved': self.rooks_moved, 'kings_moved': "
         'self.kings_moved,\n',
         "                'pawn_histories': self.pawn_histories, 'last_pawn_move': "
         'self.last_pawn_move,\n',
         "                'num_consecutive_non_pawn_moves': "
         'self.num_consecutive_non_pawn_moves,\n',
         "                'game_status': self.game_status, 'condition': "
         "self.condition, 'winner': self.winner}\n",
         '\n',
         '    def reset_non_pawn_moves(self):\n',
         '        """ a pawn has just moved, so reset number of consecutive non pawn '
         'moves to 0"""\n',
         '        self.num_consecutive_non_pawn_moves = 0\n',
         '\n',
         '    def delete_pawn(self, id):\n',
         '        """delete pawn with id from pawn histories"""\n',
         '        del self.pawn_histories[id]\n',
         '\n',
         '    def has_king_moved(self, color):\n',
         '        """return true/false of if the King of color has moved from its '
         'starting position"""\n',
         "        if color == 'W':\n",
         '            return self.kings_moved[(5, 1)]\n',
         "        elif color == 'B':\n",
         '            return self.kings_moved[(5, 8)]\n',
         '        else:\n',
         "            print('error: not a valid color\\n')\n",
         '            return -1\n',
         '\n',
         '    def get_start_king(self, color):\n',
         '        """get starting position of king based off of color"""\n',
         "        if color == 'W':\n",
         '            return (5, 1)\n',
         "        elif color == 'B':\n",
         '            return (5, 8)\n',
         '        else:\n',
         "            print('error:invalid color')\n",
         '            return -1\n',
         '\n',
         '    def update_rook_dict(self, rooks_moved):\n',
         '        """update rooks_moved dict to a new one"""\n',
         '        self.rooks_moved = rooks_moved\n',
         '\n',
         '    def queen_side_rook_moved(self, color):\n',
         '        """return true if the queen side rook of the given color has moved, '
         'otherwise false"""\n',
         '\n',
         "        if color == 'W':\n",
         '            return self.rooks_moved[(1, 1)]\n',
         "        elif color == 'B':\n",
         '            return self.rooks_moved[(1, 8)]\n',
         '\n',
         '    def king_side_rook_moved(self, color):\n',
         '        """return true if the king side rook of the given color has moved, '
         'otherwise false"""\n',
         '\n',
         "        if color == 'W':\n",
         '            return self.rooks_moved[(8, 1)]\n',
         "        elif color == 'B':\n",
         '            return self.rooks_moved[(8, 8)]\n',
         '\n',
         '    def __str__(self):\n',
         '        """called when object is argument to print"""\n',
         '\n',
         '        str_ = ""\n',
         '\n',
         '        str_ += \'"rooks_moved": {\\n\'\n',
         '        for k, v in self.rooks_moved.items():\n',
         '            str_ += str(k)\n',
         "            str_ += ':'\n",
         '            str_ += str(v)\n',
         "            str_ += '\\n'\n",
         "        str_ += '},\\n'\n",
         '\n',
         '        str_ += \'"kings_moved": {\\n\'\n',
         '        for k, v in self.kings_moved.items():\n',
         '            str_ += str(k)\n',
         "            str_ += ':'\n",
         '            str_ += str(v)\n',
         "            str_ += '\\n'\n",
         "        str_ += '},\\n'\n",
         '\n',
         '        str_ += \'"pawn_histories": {\\n\'\n',
         '        for k, v in self.pawn_histories.items():\n',
         '            str_ += str(k)\n',
         "            str_ += ':'\n",
         '            str_ += str(v)\n',
         "            str_ += '\\n'\n",
         "        str_ += '},\\n'\n",
         '\n',
         "        str_ += 'last_pawn_move'\n",
         "        str_ += ':'\n",
         '        str_ += str(self.last_pawn_move)\n',
         "        str_ += ',\\n'\n",
         '\n',
         "        str_ += 'num_consecutive_non_pawn_moves'\n",
         "        str_ += ':'\n",
         '        str_ += str(self.num_consecutive_non_pawn_moves)\n',
         "        str_ += ',\\n'\n",
         '\n',
         "        str_ += 'game_status'\n",
         "        str_ += ':'\n",
         '        str_ += str(self.game_status)\n',
         "        str_ += ',\\n'\n",
         '\n',
         "        str_ += 'winner'\n",
         "        str_ += ':'\n",
         '        str_ += str(self.winner)\n',
         "        str_ += ',\\n'\n",
         '\n',
         '        return str_\n',
         '\n',
         '\n',
         'if __name__ == "__main__":\n',
         '    pass  # TODO: implement test']
    lines = snake_to_camel(lines)
    for line in lines:
        print(line, end="")